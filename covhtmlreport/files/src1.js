var g_data = {"name":"tb/tb_one_mac_gemm.sv","src":"module tb_one_mac_gemm;\n  //---------------------------\n  // Design Time Parameters\n  //---------------------------\n\n  //---------------------------\n  // DESIGN NOTE:\n  // Parameters are a way to customize your design at\n  // compile time. Here we define the data width,\n  // memory depth, and number of ports for the\n  // multi-port memory instances used in the DUT.\n  //\n  // In other test benches, you can also have test parameters,\n  // such as the number of tests to run, or the sizes of\n  // matrices to be used in the tests.\n  //\n  // You can customize these parameters as needed.\n  // Or you can also add your own parameters.\n  //---------------------------\n\n  // General Parameters\n  parameter int unsigned InDataWidth   = 8;\n  parameter int unsigned OutDataWidth  = 32;\n  parameter int unsigned DataDepth     = 4096;\n  parameter int unsigned AddrWidth     = (DataDepth <= 1) ? 1 : $clog2(DataDepth);\n  parameter int unsigned SizeAddrWidth = 8;\n\n  // Test Parameters\n  parameter int unsigned MaxNum   = 32;\n  parameter int unsigned NumTests = 10;\n\n  parameter int unsigned SingleM = 8;\n  parameter int unsigned SingleK = 8;\n  parameter int unsigned SingleN = 8;\n\n  //---------------------------\n  // Wires\n  //---------------------------\n\n  // Size control\n  logic [SizeAddrWidth-1:0] M_i, K_i, N_i;\n\n  // Clock, reset, and other signals\n  logic clk_i;\n  logic rst_ni;\n  logic start;\n  logic done;\n\n  //---------------------------\n  // Memory\n  //---------------------------\n  // Golden data dump\n  logic signed [OutDataWidth-1:0] G_memory [DataDepth];\n\n  // Memory control\n  logic [AddrWidth-1:0] sram_a_addr;\n  logic [AddrWidth-1:0] sram_b_addr;\n  logic [AddrWidth-1:0] sram_c_addr;\n\n  // Memory access\n  logic signed [ InDataWidth-1:0] sram_a_rdata;\n  logic signed [ InDataWidth-1:0] sram_b_rdata;\n  logic signed [OutDataWidth-1:0] sram_c_wdata;\n  logic                           sram_c_we;\n\n  //---------------------------\n  // Declaration of input and output memories\n  //---------------------------\n\n  //---------------------------\n  // DESIGN NOTE:\n  // These are where the memories are instantiated for the DUT.\n  // You can modify the data width and data depth parameters.\n  //\n  // This can be useful for increasing your memory bandwidth.\n  // However, you need to think about and take care of how to,\n  // initialize the memories accordingly.\n  // That includes knowing how to pack the data accordingly.\n  //\n  // Make sure that the connection for the address, data, and wen\n  // signals are consistent with the number of ports.\n  //\n  // Refer to the single_port_memory.sv and \n  // tb_single_port_memory.sv file for more details.\n  //---------------------------\n\n  // Input memory A\n  // Note: this is read only\n  single_port_memory #(\n    .DataWidth     ( InDataWidth  ),\n    .DataDepth     ( DataDepth    ),\n    .AddrWidth     ( AddrWidth    )\n  ) i_sram_a (\n    .clk_i         ( clk_i        ),\n    .rst_ni        ( rst_ni       ),\n    .mem_addr_i    ( sram_a_addr  ),\n    .mem_we_i      ( '0           ),\n    .mem_wr_data_i ( '0           ),\n    .mem_rd_data_o ( sram_a_rdata )\n  );\n\n  // Input memory B\n  // Note: this is read only\n  single_port_memory #(\n    .DataWidth     ( InDataWidth  ),\n    .DataDepth     ( DataDepth    ),\n    .AddrWidth     ( AddrWidth    )\n  ) i_sram_b (\n    .clk_i         ( clk_i        ),\n    .rst_ni        ( rst_ni       ),\n    .mem_addr_i    ( sram_b_addr  ),\n    .mem_we_i      ( '0           ),\n    .mem_wr_data_i ( '0           ),\n    .mem_rd_data_o ( sram_b_rdata )\n  );\n\n  // Output memory C\n  // Note: this is write only\n  single_port_memory #(\n    .DataWidth     ( OutDataWidth ),\n    .DataDepth     ( DataDepth    ),\n    .AddrWidth     ( AddrWidth    )\n  ) i_sram_c (\n    .clk_i         ( clk_i        ),\n    .rst_ni        ( rst_ni       ),\n    .mem_addr_i    ( sram_c_addr  ),\n    .mem_we_i      ( sram_c_we    ),\n    .mem_wr_data_i ( sram_c_wdata ),\n    .mem_rd_data_o ( /* unused */ )\n  );\n\n  //---------------------------\n  // DUT instantiation\n  //---------------------------\n  gemm_accelerator_top #(\n    .InDataWidth   ( InDataWidth   ),\n    .OutDataWidth  ( OutDataWidth  ),\n    .AddrWidth     ( AddrWidth     ),\n    .SizeAddrWidth ( SizeAddrWidth )\n  ) i_dut (\n    .clk_i          ( clk_i        ),\n    .rst_ni         ( rst_ni       ),\n    .start_i        ( start        ),\n    .N_size_i       ( N_i          ),\n    .M_size_i       ( M_i          ),\n    .K_size_i       ( K_i          ),\n    .sram_a_addr_o  ( sram_a_addr  ),\n    .sram_b_addr_o  ( sram_b_addr  ),\n    .sram_c_addr_o  ( sram_c_addr  ),\n    .sram_a_rdata_i ( sram_a_rdata ),\n    .sram_b_rdata_i ( sram_b_rdata ),\n    .sram_c_wdata_o ( sram_c_wdata ),\n    .sram_c_we_o    ( sram_c_we    ),\n    .done_o         ( done         )\n  );\n\n  //---------------------------\n  // Tasks and functions\n  //---------------------------\n  `include \"includes/common_tasks.svh\"\n  `include \"includes/test_tasks.svh\"\n  `include \"includes/test_func.svh\"\n\n  //---------------------------\n  // Test control\n  //---------------------------\n\n  // Clock generation\n  initial begin\n    clk_i = 1'b0;\n    forever #5 clk_i = ~clk_i;  // 100MHz clock\n  end\n\n  //---------------------------\n  // DESIGN NOTE:\n  //\n  // The sequence driver is usually the main stimulus\n  // generator for the test bench. Here is where\n  // you define the sequence of operations to be\n  // performed during the simulation.\n  //\n  // It often starts with an initial reset sequence,\n  // by loading default values and asserting the reset.\n  //\n  // We also do for-loops to run multiple tests\n  // with different input parameters. In this case,\n  // we randomize the matrix sizes for each test.\n  //\n  // You can also customize in here the way\n  // the memories are initialized, how the golden\n  // results are generated, and how the results\n  // are verified.\n  //\n  // Refer to the tasks and functions included above\n  // for more details.\n  //---------------------------\n\n  // Sequence driver\n  initial begin\n\n    // Initial reset\n    start  = 1'b0;\n    rst_ni = 1'b0;\n    #50;\n    rst_ni = 1'b1;\n\n    for (integer num_test = 0; num_test < NumTests; num_test++) begin\n      $display(\"Test number: %0d\", num_test);\n\n      if (NumTests > 1) begin\n        M_i = $urandom_range(1, MaxNum);\n        K_i = $urandom_range(1, MaxNum);\n        N_i = $urandom_range(1, MaxNum);\n      end else begin\n        M_i = SingleM;\n        K_i = SingleK;\n        N_i = SingleN;\n      end\n\n      $display(\"M: %0d, K: %0d, N: %0d\", M_i, K_i, N_i);\n\n      //---------------------------\n      // DESIGN NOTE:\n      // You will most likely modify this part\n      // to initialize the input memories\n      // according to your design requirements.\n      //\n      // In here, we simply fill the memories\n      // with random data for testing.\n      //\n      // We assume a row-major storage for both matrices A and B.\n      // Row major means that the elements of each row\n      // are stored in contiguous memory locations.\n      //\n      // We also make the assumption that the matrix output C\n      // will be stored in row-major format as well.\n      //\n      // Take note that you WILL change this part according to your design.\n      // Just make sure that the way you initialize the memories\n      // is consistent with the way you generate the golden results\n      // and the way your DUT reads/writes the data.\n      //\n      // The tricky part here is that since the data accesses are\n      // shared within a single long bit-width (suppose you use longer)\n      // memory word. For example, if your memory word is 32 bits wide\n      // and your data width is 8 bits, then you can pack\n      // 4 data elements in a single memory word.\n      // So when you initialize the memory, you need to\n      // make sure that the data elements are packed\n      // correctly within each memory word.\n      //---------------------------\n\n      // Initialize memories with random data\n      for (integer m = 0; m < M_i; m++) begin\n        for (integer k = 0; k < K_i; k++) begin\n          i_sram_a.memory[m*K_i+k] = $urandom() % (2 ** InDataWidth);\n        end\n      end\n\n      for (integer k = 0; k < K_i; k++) begin\n        for (integer n = 0; n < N_i; n++) begin\n          i_sram_b.memory[k*N_i+n] = $urandom() % (2 ** InDataWidth);\n        end\n      end\n\n      // Generate golden result\n      gemm_golden(M_i, K_i, N_i, i_sram_a.memory, i_sram_b.memory, G_memory);\n\n      // Just delay 1 cycle\n      clk_delay(1);\n\n      // Execute the GeMM\n      start_and_wait_gemm();\n\n      // Verify the result\n      verify_result_c(G_memory, i_sram_c.memory, DataDepth,\n                      0 // Set this to 1 to make mismatches fatal\n      );\n\n      // Just some trailing cycles\n      // For easier monitoring in waveform\n      clk_delay(10);\n    end\n\n    $display(\"All test tasks completed successfully!\");\n    $finish;\n  end\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);