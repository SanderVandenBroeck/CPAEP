var g_data = {"name":"includes/test_func.svh","src":"//--------------------------\n// Useful functions for testing\n//--------------------------\nfunction automatic void gemm_golden(\n  input  logic [SizeAddrWidth-1:0] Mi,\n  input  logic [SizeAddrWidth-1:0] Ki,\n  input  logic [SizeAddrWidth-1:0] Ni,\n  input  logic signed [ InDataWidthA-1:0] A_i [DataDepth],\n  input  logic signed [ InDataWidthB-1:0] B_i [DataDepth],\n  output logic signed [ OutDataWidth-1:0] Y_o [goldenTempSize]\n);\n  // int unsigned m, n, k;\n  // int signed acc;\n\n  // for (m = 0; m < M; m++) begin\n  //   for (n = 0; n < N; n++) begin\n  //     acc = 0;\n  //     for (k = 0; k < K; k++) begin\n  //       acc += $signed(A_i[m*K + k]) * $signed(B_i[k*N + n]);\n  //     end\n  //     Y_o[m*N + n] = acc;\n  //   end\n  // end\n\n  int unsigned m2, n2, k2;\n  int unsigned floorA, floorExtra, tempAddrA;\n  int unsigned floorB, floorExtraB, tempAddrB;\n\n\n  // Use constant bounds (DataDepth) instead of variable bounds\n\n\n  // Place concatenated words of A_i into array tempA with only 8 bit words\n  for (int unsigned t = 0; t < (Ki/K) * (Mi/M); t++) begin\n    for (int unsigned u = 0; u < M*K; u++) begin\n      tempA[t*K*M + K*M - 1 - u] = A_i[t][u*InDataWidth+:InDataWidth];\n    end\n  end\n\n  // Reorder A matrix\n  // for (int unsigned m = 0; m < Mi; m++) begin\n  //   for (int unsigned k = 0; k < Ki; k++) begin\n  //     floorKA = k/K;\n  //     floorMA = m/M;\n  //     tempAddrA = floorKA*M*Ki/K + floorMA*M*Ki + k%K + (m%M)*K; // floor(k,K)*M*K + floor(m,M)*M*Ki + mod(k,K) + mod(m,M)*K\n  //     orderedA[tempAddrA] = tempA[Ki*m + k];\n  //   end\n  // end\n  for (int unsigned t = 0; t < Ki*Mi; t+=K) begin\n    floorA = t/(M*K);\n    floorExtra = t/(M*Ki);\n    orderedA[(t%(M*K)) * (Ki/K) + floorA*K + floorExtra*(M-1)*Ki +:K] = tempA[t+:K];\n  end\n\n  // start with B input\n  // Place concatenated words of B_i into array tempB with only 8 bit words\n  for (int unsigned t = 0; t < (Ki/K) * (Ni/N); t++) begin\n    for (int unsigned u = 0; u < N*K; u++) begin\n      tempB[t*K*N + K*N - 1 - u] = B_i[t][u*InDataWidth+:InDataWidth];\n    end\n  end\n\n \n  // same as previous:\n  // for (int unsigned n = 0; n < Ni; n++) begin\n  //   for (int unsigned kB = 0; kB < Ki; kB++) begin\n  //     floorKB = kB/K;\n  //     floorNB = n/N;\n  //     tempAddrB = floorKB*N*K + floorNB*N*Ki + kB%K + (n%N)*K; // floor(k,K)*M*K + floor(m,M)*M*Ki + mod(k,K) + mod(m,M)*K\n  //     orderedBT[tempAddrB] = tempB[Ki*n + kB];\n  //   end\n  // end\n  for (int unsigned t = 0; t < Ki*Ni; t+=K) begin\n    floorB = t/(N*K);\n    floorExtraB = t/(N*Ki);\n    orderedBT[(t%(N*K)) * (Ki/K) + floorB*K + floorExtraB*(N-1)*Ki +:K] = tempB[t+:K];\n  end\n\n  // Transpose B\n  for (int unsigned i = 0; i < Ni; i++) begin // loops over rows\n    for (int unsigned j = 0; j < Ki; j++) begin // loops over columns\n      orderedB[j*Ni+i] = orderedBT[i*Ki+j];\n    end\n  end\n  \n\n\n  for (m2 = 0; m2 < Mi; m2++) begin\n    for (n2 = 0; n2 < Ni; n2++) begin\n      acc = 0;\n      for (k2 = 0; k2 < Ki; k2++) begin\n        acc += $signed(orderedA[m2*Ki + k2]) * $signed(orderedB[k2*Ni + n2]);\n      end\n      Y_o[m2*Ni + n2] = acc;\n    end\n  end\nendfunction","lang":"verilog"};
processSrcData(g_data);