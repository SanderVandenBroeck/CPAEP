var g_data = {"name":"rtl/gemm/gemm_accelerator_top.sv","src":"//---------------------------\n// The 1-MAC GeMM accelerator top module\n//\n// Description:\n// This module implements a simple General Matrix-Matrix Multiplication (GeMM)\n// accelerator using a single Multiply-Accumulate (MAC) Processing Element (PE).\n// It interfaces with three SRAMs for input matrices A and B, and output matrix C.\n//\n// It includes a controller to manage the GeMM operation and address generation logic\n// for accessing the SRAMs based on the current matrix sizes and counters.\n//\n// Parameters:\n// - InDataWidth  : Width of the input data (matrix elements).\n// - OutDataWidth : Width of the output data (result matrix elements).\n// - AddrWidth    : Width of the address bus for SRAMs.\n// - SizeAddrWidth: Width of the size parameters for matrices.\n//\n// Ports:\n// - clk_i        : Clock input.\n// - rst_ni       : Active-low reset input.\n// - start_i      : Start signal to initiate the GeMM operation.\n// - M_size_i     : Size of matrix M (number of rows in A and C\n// - K_size_i     : Size of matrix K (number of columns in A and rows in B).\n// - N_size_i     : Size of matrix N (number of columns in B and C).\n// - sram_a_addr_o: Address output for SRAM A.\n// - sram_b_addr_o: Address output for SRAM B.\n// - sram_c_addr_o: Address output for SRAM C.\n// - sram_a_rdata_i: Data input from SRAM A.\n// - sram_b_rdata_i: Data input from SRAM B.\n// - sram_c_wdata_o: Data output to SRAM C.\n// - sram_c_we_o  : Write enable output for SRAM C.\n// - done_o       : Done signal indicating completion of the GeMM operation.\n//---------------------------\n\nmodule gemm_accelerator_top #(\n  parameter int unsigned InDataWidth = 8,\n  parameter int unsigned AddrWidth = 16,\n  parameter int unsigned SizeAddrWidth = 8,\n  parameter int unsigned M = 4,\n  parameter int unsigned N = 4,\n  parameter int unsigned K = 4,\n  parameter int unsigned OutDataWidth = 32,\n  parameter int unsigned AddrWidthC = 10\n) (\n  input  logic                            clk_i,\n  input  logic                            rst_ni,\n  input  logic                            start_i,\n  input  logic        [$clog2(32):0] M_size_i,\n  input  logic        [$clog2(64):0] K_size_i,\n  input  logic        [$clog2(32):0] N_size_i,\n  output logic        [    AddrWidth-1:0] sram_a_addr_o,\n  output logic        [    AddrWidth-1:0] sram_b_addr_o,\n  output logic        [   AddrWidthC-1:0] sram_c_addr_o,\n  input  logic signed [  InDataWidth*M*K-1:0] sram_a_rdata_i,\n  input  logic signed [  InDataWidth*K*N-1:0] sram_b_rdata_i,\n  output logic signed [ OutDataWidth*M*N-1:0] sram_c_wdata_o,\n  output logic                            sram_c_we_o,\n  output logic                            done_o\n);\n\n  //---------------------------\n  // Wires\n  //---------------------------\n  logic [SizeAddrWidth-$clog2(M)-1:0] M_count;\n  logic [SizeAddrWidth-$clog2(K)-1:0] K_count;\n  logic [SizeAddrWidth-$clog2(N)-1:0] N_count;\n  logic busy;\n  logic valid_data;\n  logic we,move_M_counter;\n  assign valid_data = (K_count == K_size_i/K - 1) || start_i || busy;  // Always valid in this simple design\n\n  //---------------------------\n  // DESIGN NOTE:\n  // This is a simple GeMM accelerator design using a single MAC PE.\n  // The controller manages just the counting capabilities.\n  // Check the gemm_controller.sv file for more details.\n  //\n  // Essentially, it tightly couples the counters and an FSM together.\n  // The address generation logic is just after this controller.\n  //\n  // You have the option to combine the address generation and controller\n  // all in one module if you prefer. We did this intentionally to separate tasks.\n  //---------------------------\n\n  // Main GeMM controller\n  gemm_controller #(\n    .AddrWidth      ( SizeAddrWidth ),\n    .K(K),\n    .M(M),\n    .N(N)\n  ) i_gemm_controller (\n    .clk_i          ( clk_i       ),\n    .rst_ni         ( rst_ni      ),\n    .start_i        ( start_i     ),\n    .input_valid_i  ( 1'b1        ),  // Always valid in this simple design\n    .result_valid_o ( sram_c_we_o ),\n    .busy_o         ( busy        ),\n    .done_o         ( done_o      ),\n    .M_size_i       ( M_size_i    ),\n    .K_size_i       ( K_size_i    ),\n    .N_size_i       ( N_size_i    ),\n    .M_count_o      ( M_count     ),\n    .K_count_o      ( K_count     ),\n    .N_count_o      ( N_count     )\n  );\n  //---------------------------\n  // DESIGN NOTE:\n  // This part is the address generation logic for the input and output SRAMs.\n  // In our example, we made the assumption that both matrices A and B\n  // are stored in row-major order.\n//\n  // Please adjust this part to align with your designed memory layout\n  // The counters are used for the matrix A and matrix B address generation;\n  // for matrix C, the corresponding address is calculated at the previous cycle,\n  // thus adding one cycle delay on c\n  //\n  // Just be careful to know on which cycle the addresses are valid.\n  // Align it carefully with the testbench's memory control.\n  //---------------------------\n\n  // Input addresses for matrices A and B\n  assign sram_a_addr_o = (M_count * K_size_i/K + K_count);\n  assign sram_b_addr_o =  (N_count * K_size_i/K + K_count); //(K_count * N_size_i/N + N_count); //\n\n  // Output address for matrix C\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      sram_c_addr_o <= '0;\n    end else if (1'b1) begin  // Always valid in this simple design\n      sram_c_addr_o <= (M_count * N_size_i/N + N_count);\n    end\n  end\n\n  //---------------------------\n  // DESIGN NOTE:\n  // This part is the MAC PE instantiation and data path logic.\n  // Check the general_mac_pe.sv file for more details.\n  //\n  // In this example, we only use a single MAC PE hence it is a simple design.\n  // However, you can expand this part to support multiple PEs\n  // by adjusting the data widths and input/output connections accordingly.\n  //\n  // Systemverilog has a useful mechanism to generate multiple instances\n  // using generate-for loops.\n  // Below is an example of a 2D generate-for loop to create a grid of PEs.\n  //\n  // ----------- BEGIN CODE EXAMPLE -----------\n  // genvar m, k, n;\n  //\n  //   for (m = 0; m < M; m++) begin : gem_mac_pe_m\n  //     for (n = 0; n < N; n++) begin : gem_mac_pe_n\n  //         mac_module #(\n  //           < insert parameters >\n  //         ) i_mac_pe (\n  //           < insert port connections >\n  //         );\n  //     end\n  //   end\n  // ----------- END CODE EXAMPLE -----------\n  // mem_rd_data_o\n  // There are many guides on the internet (or even ChatGPT) about generate-for loops.\n  // We will give it as an exercise to you to modify this part to support multiple MAC PEs.\n  // \n  // When dealing with multiple PEs, be careful with the connection alignment\n  // across different PEs as it can be tricky to debug later on.\n  // Plan this very carefully, especially when delaying with the correct data ports\n  // data widths, slicing, valid signals, and so much more.\n  //\n  // Additionally, this MAC PE is already output stationary.\n  // You have the freedom to change the dataflow as you see fit.\n  //---------------------------\n\n\n  genvar m, k, n, i;\n  generate\n  for (n = 0; n < N; n++) begin : gem_mac_pe_n\n    for (m = 0; m < M; m++) begin : gem_mac_pe_m\n      logic [OutDataWidth-1:0] wdata;\n      general_mac_pe #(\n        .InDataWidth  ( InDataWidth            ),\n        .NumInputs    ( K                      ),\n        .OutDataWidth ( OutDataWidth           )\n      ) i_mac_pe (\n        .clk_i        ( clk_i                  ),\n        .rst_ni       ( rst_ni                 ),\n        .a_i          ( sram_a_rdata_i[(M-m)*K*8-K*8+:K*8] ),\n        .b_i          ( sram_b_rdata_i[(N-n)*K*8-K*8+:K*8] ),        // [(N-n)*Ki*8]          \n        .a_valid_i    ( valid_data             ),\n        .b_valid_i    ( valid_data             ),\n        .init_save_i  ( sram_c_we_o || start_i ),\n        .acc_clr_i    ( !busy                  ),\n        .c_o          ( wdata         )\n      );\n    end\n  end\n  for (m = 0; m < M; m++) begin : gem_c_wdata_m\n    for (n = 0; n < N; n++) begin : gem_c_wdata_n\n      assign sram_c_wdata_o[(m*N + n)*OutDataWidth +: OutDataWidth] = gem_mac_pe_n[n].gem_mac_pe_m[m].wdata;\n    end\n  end\n  endgenerate\n\n\nendmodule\n","lang":"verilog"};
processSrcData(g_data);